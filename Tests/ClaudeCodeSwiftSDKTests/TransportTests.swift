// Generated by Claude

import Testing
import Foundation
@testable import ClaudeCodeSwiftSDK

@Suite("Subprocess CLI Transport Tests")
struct SubprocessCLITransportTests {
    
    @Test("Transport initialization with valid CLI path")
    func transportInitializationWithValidCLIPath() {
        // Test that transport can be created with a valid CLI path
        let cliPath = URL(fileURLWithPath: "/usr/bin/claude")
        let options = ClaudeCodeOptions()
        
        // This would create a transport with the specified CLI path
        // In a real test, we'd verify the transport stores the path correctly
        #expect(cliPath.path == "/usr/bin/claude")
        #expect(options.allowedTools == [])
    }
    
    @Test("Build command with basic options")
    func buildCommandWithBasicOptions() {
        // Test that the transport builds the correct CLI command
        let options = ClaudeCodeOptions(
            systemPrompt: "Be helpful",
            maxTurns: 5,
            allowedTools: ["Read", "Write"],
            disallowedTools: ["Bash"],
            permissionMode: .acceptEdits,
            model: "claude-3-5-sonnet"
        )
        
        // Verify options are set correctly
        #expect(options.systemPrompt == "Be helpful")
        #expect(options.allowedTools == ["Read", "Write"])
        #expect(options.disallowedTools == ["Bash"])
        #expect(options.model == "claude-3-5-sonnet")
        #expect(options.permissionMode == ClaudeCodeOptions.PermissionMode.acceptEdits)
        #expect(options.maxTurns == 5)
        
        // In a real implementation, we'd test that these options
        // are correctly converted to CLI arguments
    }
    
    @Test("Build command with add directories")
    func buildCommandWithAddDirectories() {
        let dir1 = URL(fileURLWithPath: "/path/to/dir1")
        let dir2 = URL(fileURLWithPath: "/path/to/dir2")
        
        let options = ClaudeCodeOptions(addDirs: [dir1, dir2])
        
        #expect(options.addDirs.count == 2)
        #expect(options.addDirs[0] == dir1)
        #expect(options.addDirs[1] == dir2)
        
        // In a real implementation, we'd verify these are converted
        // to the correct --add-dir CLI arguments
    }
    
    @Test("Session continuation options")
    func sessionContinuationOptions() {
        let options = ClaudeCodeOptions(
            continueConversation: true,
            resume: "session-123"
        )
        
        #expect(options.continueConversation == true)
        #expect(options.resume == "session-123")
        
        // In a real implementation, we'd verify these are converted
        // to --continue and --resume CLI arguments
    }
    
    @Test("CLI path discovery", .disabled("Requires file system access"))
    func cliPathDiscovery() {
        // This test would verify that CLI discovery works correctly
        // It's disabled because it requires actual file system access
        
        let searchPaths = [
            URL(fileURLWithPath: "/usr/local/bin/claude"),
            URL(fileURLWithPath: "/opt/homebrew/bin/claude"),
            FileManager.default.homeDirectoryForCurrentUser
                .appendingPathComponent(".npm-global/bin/claude")
        ]
        
        // Verify search paths are reasonable
        #expect(searchPaths.count >= 3)
        #expect(searchPaths[0].lastPathComponent == "claude")
    }
    
    @Test("Transport error handling")
    func transportErrorHandling() {
        // Test various error conditions
        
        // CLI not found error
        let searchedPaths = [URL(fileURLWithPath: "/nonexistent/claude")]
        let cliNotFoundError = ClaudeSDKError.cliNotFound(searchedPaths: searchedPaths)
        
        if case .cliNotFound(let paths) = cliNotFoundError {
            #expect(paths == searchedPaths)
        } else {
            Issue.record("Expected cliNotFound error")
        }
        
        // Process error
        let processError = ClaudeSDKError.processError(message: "Command failed", exitCode: 127)
        
        if case .processError(let message, let exitCode) = processError {
            #expect(message == "Command failed")
            #expect(exitCode == 127)
        } else {
            Issue.record("Expected processError")
        }
        
        // Connection error
        let underlyingError = NSError(domain: "TestDomain", code: 1)
        let connectionError = ClaudeSDKError.cliConnectionError(underlying: underlyingError)
        
        if case .cliConnectionError(let underlying) = connectionError {
            #expect((underlying as NSError).domain == "TestDomain")
        } else {
            Issue.record("Expected cliConnectionError")
        }
    }
    
    @Test("Working directory validation")
    func workingDirectoryValidation() {
        // Test that working directory options are handled correctly
        let customPath = URL(fileURLWithPath: "/custom/working/directory")
        let options = ClaudeCodeOptions(cwd: customPath)
        
        #expect(options.cwd == customPath)
        #expect(options.cwd?.path == "/custom/working/directory")
        
        // In a real implementation, we'd verify that non-existent directories
        // are handled appropriately (either with an error or creating them)
    }
    
    @Test("Command argument escaping", .disabled("Requires full implementation"))
    func commandArgumentEscaping() {
        // Test that arguments with spaces and special characters are properly escaped
        let options = ClaudeCodeOptions(
            systemPrompt: "You are a helpful assistant with \"quotes\" and spaces",
            cwd: URL(fileURLWithPath: "/path with spaces/to directory")
        )
        
        #expect(options.systemPrompt?.contains("\"") == true)
        #expect(options.cwd?.path.contains(" ") == true)
        
        // In a real implementation, we'd verify proper shell escaping
    }
    
    @Test("MCP server configuration with dictionary")
    func mcpServerConfigurationWithDictionary() {
        let stdioServer = McpStdioServerConfig(
            command: "python",
            args: ["-m", "my_server"],
            env: ["PATH": "/usr/bin"]
        )
        
        let sseServer = McpSSEServerConfig(
            url: "https://api.example.com/mcp",
            headers: ["Authorization": "Bearer token"]
        )
        
        let mcpServers: [String: any MCPServerConfig] = [
            "stdio-server": stdioServer,
            "sse-server": sseServer
        ]
        
        let options = ClaudeCodeOptions(mcpServers: .dictionary(mcpServers))
        
        if case .dictionary(let servers) = options.mcpServers {
            #expect(servers.count == 2)
            #expect(servers["stdio-server"] != nil)
            #expect(servers["sse-server"] != nil)
        } else {
            Issue.record("Expected dictionary MCP servers configuration")
        }
        
        // Verify server configurations
        #expect(stdioServer.command == "python")
        #expect(stdioServer.args == ["-m", "my_server"])
        #expect(stdioServer.env?["PATH"] == "/usr/bin")
        
        #expect(sseServer.url == "https://api.example.com/mcp")
        #expect(sseServer.headers?["Authorization"] == "Bearer token")
    }
    
    @Test("MCP server configuration with JSON string")
    func mcpServerConfigurationWithString() {
        let jsonConfig = """
        {
            "mcpServers": {
                "test-server": {
                    "type": "stdio",
                    "command": "/path/to/server",
                    "args": ["--option", "value"]
                }
            }
        }
        """
        
        let options = ClaudeCodeOptions(mcpServers: .string(jsonConfig))
        
        if case .string(let configString) = options.mcpServers {
            #expect(configString.contains("test-server"))
            #expect(configString.contains("/path/to/server"))
        } else {
            Issue.record("Expected string MCP servers configuration")
        }
    }
    
    @Test("MCP server configuration with file path")
    func mcpServerConfigurationWithPath() {
        let configPath = URL(fileURLWithPath: "/path/to/mcp-config.json")
        
        let options = ClaudeCodeOptions(mcpServers: .path(configPath))
        
        if case .path(let filePath) = options.mcpServers {
            #expect(filePath == configPath)
            #expect(filePath.path == "/path/to/mcp-config.json")
        } else {
            Issue.record("Expected path MCP servers configuration")
        }
    }
    
    @Test("MCP server configuration with builder")
    func mcpServerConfigurationWithBuilder() {
        let stdioServer = McpStdioServerConfig(
            command: "python",
            args: ["-m", "server"],
            env: ["PYTHONPATH": "/opt/server"]
        )
        
        let servers: [String: any MCPServerConfig] = [
            "test-server": stdioServer
        ]
        
        // Test dictionary builder method
        let options1 = ClaudeCodeOptionsBuilder()
            .mcpServers(servers)
            .build()
        
        if case .dictionary(let dictServers) = options1.mcpServers {
            #expect(dictServers.count == 1)
            #expect(dictServers["test-server"] != nil)
        } else {
            Issue.record("Expected dictionary MCP servers from builder")
        }
        
        // Test string builder method
        let jsonString = "{\"mcpServers\": {\"string-server\": {\"type\": \"stdio\"}}}"
        let options2 = ClaudeCodeOptionsBuilder()
            .mcpServersFromString(jsonString)
            .build()
        
        if case .string(let configString) = options2.mcpServers {
            #expect(configString == jsonString)
        } else {
            Issue.record("Expected string MCP servers from builder")
        }
        
        // Test path builder method
        let configPath = URL(fileURLWithPath: "/config/mcp.json")
        let options3 = ClaudeCodeOptionsBuilder()
            .mcpServersFromPath(configPath)
            .build()
        
        if case .path(let filePath) = options3.mcpServers {
            #expect(filePath == configPath)
        } else {
            Issue.record("Expected path MCP servers from builder")
        }
    }
    
    @Test("Build command with extra args for future CLI flags")
    func buildCommandWithExtraArgs() {
        // Test building CLI command with extra_args for future flags
        let options = ClaudeCodeOptions(
            extraArgs: [
                "new-flag": "value",
                "boolean-flag": nil,
                "another-option": "test-value"
            ]
        )
        
        // Verify extra args are set correctly
        #expect(options.extraArgs.count == 3)
        #expect(options.extraArgs["new-flag"] == "value")
        #expect(options.extraArgs["boolean-flag"] != nil) // Key exists
        #expect(options.extraArgs["boolean-flag"]! == nil) // Value is nil (boolean flag)
        #expect(options.extraArgs["another-option"] == "test-value")
        
        // In a real implementation, this would generate:
        // --new-flag value --boolean-flag --another-option test-value
    }
    
    @Test("Build command with settings as file path")
    func buildCommandWithSettingsFile() {
        // Test building CLI command with settings as file path
        let options = ClaudeCodeOptions(
            settings: "/path/to/settings.json"
        )
        
        #expect(options.settings == "/path/to/settings.json")
        
        // In a real implementation, this would generate:
        // --settings /path/to/settings.json
    }
    
    @Test("Build command with settings as JSON object")  
    func buildCommandWithSettingsJson() {
        // Test building CLI command with settings as JSON object
        let settingsJson = "{\"permissions\": {\"allow\": [\"Bash(ls:*)\"]}}";
        let options = ClaudeCodeOptions(
            settings: settingsJson
        )
        
        #expect(options.settings == settingsJson)
        
        // In a real implementation, this would generate:
        // --settings {"permissions": {"allow": ["Bash(ls:*)"]}}
    }
    
    @Test("Extra args command building integration", .disabled("Requires SubprocessCLI internal access"))
    func extraArgsCommandBuildingIntegration() {
        // This would test the actual command building with extra args
        // It's disabled because it requires access to the internal buildArguments method
        
        let options = ClaudeCodeOptions(
            systemPrompt: "test prompt",
            extraArgs: [
                "new-flag": "value",
                "boolean-flag": nil,
                "file-path": "/path/to/file.txt"
            ]
        )
        
        // In a real implementation with access to buildArguments:
        // let transport = SubprocessCLITransport(cliPath: URL(fileURLWithPath: "/test/claude"))
        // let args = transport.buildArguments(isStreaming: false, options: options)
        // 
        // Expected args would include:
        // ["--output-format", "stream-json", "--verbose", "--system-prompt", "test prompt", 
        //  "--new-flag", "value", "--boolean-flag", "--file-path", "/path/to/file.txt", "--print"]
        
        #expect(options.systemPrompt == "test prompt")
        #expect(options.extraArgs["new-flag"] == "value")
        #expect(options.extraArgs["boolean-flag"] == nil)
        #expect(options.extraArgs["file-path"] == "/path/to/file.txt")
    }
}