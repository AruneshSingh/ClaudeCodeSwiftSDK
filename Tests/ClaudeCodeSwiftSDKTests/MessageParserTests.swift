// Generated by Claude

import Testing
import Foundation
@testable import ClaudeCodeSwiftSDK

@Suite("Message Decoder Tests")
struct MessageDecoderTests {
    
    @Test("Decode valid user message with text", .disabled("MessageDecoder needs proper JSON structure"))
    func decodeValidUserMessageWithText() async throws {
        // Note: The MessageDecoder expects Claude CLI output format
        // This test is disabled until we implement proper test data structure
        
        let userMessage = UserMessage(content: "Hello, Claude!", sessionId: "test-session")
        if case .text(let text) = userMessage.content {
            #expect(text == "Hello, Claude!")
        } else {
            Issue.record("Expected text content")
        }
    }
    
    @Test("Message types can be created directly")
    func messageTypesCanBeCreatedDirectly() {
        // Test direct creation of message types
        
        let userMessage = UserMessage(content: "Test message", sessionId: "test-session")
        #expect(userMessage != nil)
        
        let textBlock = TextBlock(text: "Test text")
        let assistantMessage = AssistantMessage(
            id: "test-id",
            content: [textBlock], 
            model: "test-model",
            sessionId: "test-session"
        )
        #expect(assistantMessage.content.count == 1)
        
        let systemMessage = SystemMessage(subtype: "start", genericData: [:])
        #expect(systemMessage.subtype == "start")
        
        let resultMessage = ResultMessage(
            subtype: "success",
            durationMs: 1000,
            durationApiMs: 500,
            isError: false,
            numTurns: 1,
            sessionId: "test-session"
        )
        #expect(resultMessage.isError == false)
    }
    
    @Test("Content blocks work correctly")
    func contentBlocksWorkCorrectly() {
        // Test content block types
        
        let textBlock = TextBlock(text: "Hello")
        #expect(textBlock.text == "Hello")
        
        let toolUseBlock = ToolUseBlock(
            id: "tool-123",
            name: "Read",
            input: ["file_path": AnyCodable("/test.txt")]
        )
        #expect(toolUseBlock.id == "tool-123")
        #expect(toolUseBlock.name == "Read")
        
        let toolResultBlock = ToolResultBlock(
            toolUseId: "tool-123",
            content: .text("File contents"),
            isError: false
        )
        #expect(toolResultBlock.toolUseId == "tool-123")
        if case .text(let content) = toolResultBlock.content {
            #expect(content == "File contents")
        } else {
            Issue.record("Expected text content")
        }
    }
    
    @Test("User message with blocks content")
    func userMessageWithBlocksContent() {
        let textBlock = TextBlock(text: "Hello")
        let toolUseBlock = ToolUseBlock(
            id: "tool-456",
            name: "Read",
            input: ["file_path": AnyCodable("/example.txt")]
        )
        
        let userMessage = UserMessage(content: [textBlock, toolUseBlock], sessionId: "test-session")
        
        if case .blocks(let blocks) = userMessage.content {
            #expect(blocks.count == 2)
            
            if let firstBlock = blocks[0] as? TextBlock {
                #expect(firstBlock.text == "Hello")
            } else {
                Issue.record("Expected TextBlock as first block")
            }
            
            if let secondBlock = blocks[1] as? ToolUseBlock {
                #expect(secondBlock.id == "tool-456")
                #expect(secondBlock.name == "Read")
            } else {
                Issue.record("Expected ToolUseBlock as second block")
            }
        } else {
            Issue.record("Expected blocks content")
        }
    }
    
    @Test("Error scenarios", .disabled("Full error testing requires integration"))
    func errorScenarios() {
        // Test various error conditions that would occur during actual message parsing
        // These are disabled until we have proper mocking infrastructure
        
        let error = ClaudeSDKError.jsonDecodeError(
            line: "invalid json",
            error: NSError(domain: "Test", code: 1)
        )
        
        if case .jsonDecodeError(let line, _) = error {
            #expect(line == "invalid json")
        } else {
            Issue.record("Expected jsonDecodeError")
        }
    }
    
    @Test("Parse system init message with structured data")
    func parseSystemInitMessage() throws {
        let jsonString = """
        {"type":"system","subtype":"init","cwd":"/Users/n3sh/Dev/repos/ClaudeCodeSwiftSDK/Examples/InteractiveCLI","session_id":"e974e06b-50f5-4367-a135-85ad67b9e77e","tools":["Task","Bash","Glob","Grep","LS","ExitPlanMode","Read","Edit","MultiEdit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","BashOutput","KillBash"],"mcp_servers":[],"model":"claude-sonnet-4-20250514","permissionMode":"default","slash_commands":["add-dir","agents","clear","compact","config","cost","doctor","exit","help","ide","init","install-github-app","mcp","memory","migrate-installer","model","pr-comments","release-notes","resume","status","statusline","bug","review","security-review","terminal-setup","upgrade","vim","permissions","hooks","export","logout","login","bashes"],"apiKeySource":"none"}
        """
        
        let data = Data(jsonString.utf8)
        let decoder = JSONDecoder()
        let message = try decoder.decode(Message.self, from: data)
        
        guard case let .system(systemMessage) = message else {
            throw TestError.unexpectedMessageType
        }
        
        #expect(systemMessage.subtype == "init")
        
        // Direct field access - much more efficient!
        #expect(systemMessage.cwd == "/Users/n3sh/Dev/repos/ClaudeCodeSwiftSDK/Examples/InteractiveCLI")
        #expect(systemMessage.sessionId == "e974e06b-50f5-4367-a135-85ad67b9e77e")
        #expect(systemMessage.model == "claude-sonnet-4-20250514")
        #expect(systemMessage.permissionMode == "default")
        #expect(systemMessage.apiKeySource == "none")
        #expect(systemMessage.tools?.contains("Task") == true)
        #expect(systemMessage.tools?.contains("Bash") == true)
        #expect(systemMessage.slashCommands?.contains("clear") == true)
        #expect(systemMessage.slashCommands?.contains("help") == true)
        #expect(systemMessage.mcpServers?.isEmpty == true)
    }
    
    enum TestError: Error {
        case unexpectedMessageType
    }
}

// MARK: - Integration Tests (Disabled)

@Suite("Message Parser Integration Tests")
struct MessageParserIntegrationTests {
    
    @Test("Full message parsing pipeline", .disabled("Requires Claude CLI integration"))
    func fullMessageParsingPipeline() async throws {
        // This would test the full pipeline from CLI output to parsed messages
        // It's disabled because it requires actual CLI integration
        
        // Example of what we'd test:
        // 1. Mock CLI output with valid JSON
        // 2. Parse it through MessageDecoder
        // 3. Verify correct message types are created
        // 4. Test error handling for malformed input
        
        #expect(Bool(true), "Integration test disabled - requires CLI")
    }
}