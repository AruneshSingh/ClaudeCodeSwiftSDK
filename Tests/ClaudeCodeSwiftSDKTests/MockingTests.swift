// Generated by Claude

import Testing
import Foundation
@testable import ClaudeCodeSwiftSDK

// MARK: - Mock Transport for Testing

/// Mock transport that doesn't require actual CLI
class MockSubprocessCLITransport {
    private var mockMessages: [Message] = []
    private var isConnected: Bool = false
    
    init(mockMessages: [Message] = []) {
        self.mockMessages = mockMessages
    }
    
    func connect() async throws {
        isConnected = true
    }
    
    func disconnect() async throws {
        isConnected = false
    }
    
    func executeQuery() -> AsyncThrowingStream<Message, Error> {
        let messages = self.mockMessages
        return AsyncThrowingStream { continuation in
            Task {
                for message in messages {
                    continuation.yield(message)
                }
                continuation.finish()
            }
        }
    }
    
    func addMockMessage(_ message: Message) {
        mockMessages.append(message)
    }
}

// MARK: - Mock Tests (equivalent to Python's mocked tests)

@Suite("Mocked Query Function Tests")
struct MockedQueryFunctionTests {
    
    @Test("Query with single prompt using mock")
    func queryWithSinglePrompt() async throws {
        // Create mock messages similar to Python test
        let assistantMessage = Message.assistant(AssistantMessage(
            id: "test-id-1",
            content: [TextBlock(text: "4")], 
            model: "test-model",
            sessionId: "test-session"
        ))
        let resultMessage = Message.result(ResultMessage(
            subtype: "success",
            durationMs: 1000,
            durationApiMs: 800,
            isError: false,
            numTurns: 1,
            sessionId: "test-session"
        ))
        
        let mockTransport = MockSubprocessCLITransport(mockMessages: [assistantMessage, resultMessage])
        
        // Simulate what the query function would do
        var messages: [Message] = []
        for try await message in mockTransport.executeQuery() {
            messages.append(message)
        }
        
        // Verify results like Python test
        #expect(messages.count == 2)
        
        // Check first message is assistant
        if case .assistant(let assistantMsg) = messages[0],
           let textBlock = assistantMsg.content[0] as? TextBlock {
            #expect(textBlock.text == "4")
        } else {
            Issue.record("Expected AssistantMessage with TextBlock")
        }
        
        // Check second message is result
        if case .result = messages[1] {
            // Success
        } else {
            Issue.record("Expected ResultMessage")
        }
    }
    
    @Test("Query with options using mock")
    func queryWithOptions() async throws {
        // Test options handling similar to Python
        let options = ClaudeCodeOptions(
            systemPrompt: "You are helpful",
            maxTurns: 5,
            allowedTools: ["Read", "Write"],
            permissionMode: .acceptEdits
        )
        
        let assistantMessage = Message.assistant(AssistantMessage(
            id: "test-id-2",
            content: [TextBlock(text: "Hello!")], 
            model: "test-model",
            sessionId: "test-session"
        ))
        let mockTransport = MockSubprocessCLITransport(mockMessages: [assistantMessage])
        
        // Verify options are correctly constructed
        #expect(options.allowedTools == ["Read", "Write"])
        #expect(options.systemPrompt == "You are helpful")
        #expect(options.permissionMode == .acceptEdits)
        #expect(options.maxTurns == 5)
        
        // Simulate query execution
        var messages: [Message] = []
        for try await message in mockTransport.executeQuery() {
            messages.append(message)
        }
        
        #expect(messages.count == 1)
        if case .assistant = messages[0] {
            // Success
        } else {
            Issue.record("Expected AssistantMessage")
        }
    }
    
    @Test("Query with custom working directory using mock")
    func queryWithCustomWorkingDirectory() async throws {
        let customPath = URL(fileURLWithPath: "/custom/path")
        let options = ClaudeCodeOptions(cwd: customPath)
        
        // Mock the message stream similar to Python test
        let assistantMessage = Message.assistant(AssistantMessage(
            id: "test-id-3",
            content: [TextBlock(text: "Done")], 
            model: "test-model",
            sessionId: "test-session"
        ))
        let resultMessage = Message.result(ResultMessage(
            subtype: "success",
            durationMs: 1000,
            durationApiMs: 800,
            isError: false,
            numTurns: 1,
            sessionId: "test-session",
            totalCostUsd: 0.001
        ))
        
        let mockTransport = MockSubprocessCLITransport(mockMessages: [assistantMessage, resultMessage])
        
        // Verify the options include the custom path
        #expect(options.cwd == customPath)
        #expect(options.cwd?.path == "/custom/path")
        
        // Execute mock query
        var messages: [Message] = []
        for try await message in mockTransport.executeQuery() {
            messages.append(message)
        }
        
        #expect(messages.count == 2)
        if case .result(let result) = messages[1] {
            #expect(result.totalCostUsd == 0.001)
            #expect(result.sessionId == "test-session")
        } else {
            Issue.record("Expected ResultMessage")
        }
    }
}

@Suite("Mocked Transport Tests")
struct MockedTransportTests {
    
    @Test("Transport connection lifecycle")
    func transportConnectionLifecycle() async throws {
        let mockTransport = MockSubprocessCLITransport()
        
        // Test connection
        try await mockTransport.connect()
        
        // Test message execution
        let testMessage = Message.assistant(AssistantMessage(
            id: "test-id-4",
            content: [TextBlock(text: "Test")], 
            model: "test-model",
            sessionId: "test-session"
        ))
        mockTransport.addMockMessage(testMessage)
        
        var receivedMessages: [Message] = []
        for try await message in mockTransport.executeQuery() {
            receivedMessages.append(message)
        }
        
        #expect(receivedMessages.count == 1)
        if case .assistant = receivedMessages[0] {
            // Success
        } else {
            Issue.record("Expected AssistantMessage")
        }
        
        // Test disconnection
        try await mockTransport.disconnect()
    }
    
    @Test("Transport command building simulation")
    func transportCommandBuildingSimulation() {
        // Simulate command building like Python's test_build_command_with_options
        let options = ClaudeCodeOptions(
            systemPrompt: "Be helpful",
            maxTurns: 5,
            allowedTools: ["Read", "Write"],
            disallowedTools: ["Bash"],
            permissionMode: .acceptEdits,
            model: "claude-3-5-sonnet"
        )
        
        // In a real implementation, we'd test that these options
        // are converted to the correct CLI command arguments
        let expectedArguments = [
            "--system-prompt", "Be helpful",
            "--max-turns", "5",
            "--allowedTools", "Read,Write",
            "--disallowedTools", "Bash",
            "--permission-mode", "acceptEdits",
            "--model", "claude-3-5-sonnet",
            "--output-format", "stream-json"
        ]
        
        // Verify all expected arguments would be present
        #expect(options.systemPrompt == "Be helpful")
        #expect(options.maxTurns == 5)
        #expect(options.allowedTools == ["Read", "Write"])
        #expect(options.disallowedTools == ["Bash"])
        #expect(options.permissionMode == .acceptEdits)
        #expect(options.model == "claude-3-5-sonnet")
        
        // In a real implementation, we'd verify the CLI command construction
        #expect(expectedArguments.contains("--system-prompt"))
        #expect(expectedArguments.contains("Be helpful"))
    }
    
    @Test("Add directories option simulation")
    func addDirectoriesOptionSimulation() {
        let dir1 = URL(fileURLWithPath: "/path/to/dir1")
        let dir2 = URL(fileURLWithPath: "/path/to/dir2")
        let options = ClaudeCodeOptions(addDirs: [dir1, dir2])
        
        #expect(options.addDirs.count == 2)
        #expect(options.addDirs[0] == dir1)
        #expect(options.addDirs[1] == dir2)
        
        // Simulate CLI command building
        var cmdArgs: [String] = []
        for dir in options.addDirs {
            cmdArgs.append("--add-dir")
            cmdArgs.append(dir.path)
        }
        
        let expectedCommand = "--add-dir /path/to/dir1 --add-dir /path/to/dir2"
        let actualCommand = cmdArgs.joined(separator: " ")
        
        #expect(actualCommand == expectedCommand)
    }
    
    @Test("Session continuation simulation")
    func sessionContinuationSimulation() {
        let options = ClaudeCodeOptions(
            continueConversation: true,
            resume: "session-123"
        )
        
        #expect(options.continueConversation == true)
        #expect(options.resume == "session-123")
        
        // Simulate building CLI command with session options
        var cmdArgs: [String] = []
        if options.continueConversation {
            cmdArgs.append("--continue")
        }
        if let resume = options.resume {
            cmdArgs.append("--resume")
            cmdArgs.append(resume)
        }
        
        #expect(cmdArgs.contains("--continue"))
        #expect(cmdArgs.contains("--resume"))
        #expect(cmdArgs.contains("session-123"))
    }
    
    @Test("Error handling with nonexistent directory")
    func errorHandlingWithNonexistentDirectory() {
        let nonexistentPath = "/this/directory/does/not/exist"
        let options = ClaudeCodeOptions(cwd: URL(fileURLWithPath: nonexistentPath))
        
        #expect(options.cwd?.path == nonexistentPath)
        
        // In a real implementation, connecting with this path would throw CLIConnectionError
        let expectedError = ClaudeSDKError.cliConnectionError(
            underlying: NSError(domain: "Test", code: 1, userInfo: [
                NSLocalizedDescriptionKey: "Directory does not exist: \(nonexistentPath)"
            ])
        )
        
        if case .cliConnectionError(let underlying) = expectedError {
            #expect(underlying.localizedDescription.contains(nonexistentPath))
        } else {
            Issue.record("Expected cliConnectionError")
        }
    }
}

@Suite("Message Stream Simulation Tests")
struct MessageStreamSimulationTests {
    
    @Test("Simulate receiving mixed message types")
    func simulateReceivingMixedMessageTypes() async throws {
        // Simulate the message stream from Python's test_receive_messages
        let messages: [Message] = [
            .assistant(AssistantMessage(
                id: "test-id-5",
                content: [TextBlock(text: "Hello!")], 
                model: "test-model",
                sessionId: "test-session"
            )),
            .user(UserMessage(content: .text("Hi there"), sessionId: "test-session")),
            .system(SystemMessage(subtype: "status", genericData: ["info": AnyCodable("Processing")])),
            .result(ResultMessage(
                subtype: "success",
                durationMs: 1500,
                durationApiMs: 1200,
                isError: false,
                numTurns: 2,
                sessionId: "test-session",
                totalCostUsd: 0.005
            ))
        ]
        
        let mockTransport = MockSubprocessCLITransport(mockMessages: messages)
        
        var receivedMessages: [Message] = []
        for try await message in mockTransport.executeQuery() {
            receivedMessages.append(message)
        }
        
        #expect(receivedMessages.count == 4)
        
        // Verify content using enum pattern matching
        if case .assistant(let assistantMsg) = receivedMessages[0],
           let textBlock = assistantMsg.content[0] as? TextBlock {
            #expect(textBlock.text == "Hello!")
        } else {
            Issue.record("Expected AssistantMessage with text")
        }
        
        if case .user(let userMsg) = receivedMessages[1],
           case .text(let content) = userMsg.content {
            #expect(content == "Hi there")
        } else {
            Issue.record("Expected UserMessage with text content")
        }
        
        if case .system = receivedMessages[2] {
            // Success
        } else {
            Issue.record("Expected SystemMessage")
        }
        
        if case .result = receivedMessages[3] {
            // Success
        } else {
            Issue.record("Expected ResultMessage")
        }
    }
    
    @Test("Simulate response stream stopping at result")
    func simulateResponseStreamStoppingAtResult() async throws {
        // Simulate Python's test_receive_response behavior
        let messages: [Message] = [
            .assistant(AssistantMessage(
                id: "test-id-6",
                content: [TextBlock(text: "Answer")], 
                model: "test-model",
                sessionId: "test-session"
            )),
            .result(ResultMessage(
                subtype: "success",
                durationMs: 1000,
                durationApiMs: 800,
                isError: false,
                numTurns: 1,
                sessionId: "test",
                totalCostUsd: 0.001
            )),
            // This should not be included in response stream
            .assistant(AssistantMessage(
                id: "test-id-7",
                content: [TextBlock(text: "Should not see this")], 
                model: "test-model",
                sessionId: "test-session"
            ))
        ]
        
        let mockTransport = MockSubprocessCLITransport(mockMessages: messages)
        
        // Simulate receive_response that stops at ResultMessage
        var receivedMessages: [Message] = []
        for try await message in mockTransport.executeQuery() {
            receivedMessages.append(message)
            
            // Stop at result message (like receive_response does)
            if case .result = message {
                break
            }
        }
        
        // Should only get 2 messages (assistant + result)
        #expect(receivedMessages.count == 2)
        
        if case .assistant = receivedMessages[0] {
            // Success
        } else {
            Issue.record("Expected AssistantMessage")
        }
        
        if case .result(let lastMsg) = receivedMessages[1] {
            #expect(lastMsg.subtype == "success")
        } else {
            Issue.record("Expected ResultMessage as last message")
        }
    }
}