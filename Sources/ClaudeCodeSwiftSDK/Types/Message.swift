// This file was generated by Claude

import Foundation

// MARK: - Message Enum

/// Unified message type for all Claude interactions
/// This enum eliminates type erasure overhead and provides better performance
public enum Message: Codable, Sendable {
    case user(UserMessage)           // User text/tool results
    case assistant(AssistantMessage) // Assistant text/tool calls  
    case system(SystemMessage)       // System metadata
    case result(ResultMessage)       // Session results
    
    // Custom Codable implementation to handle different message types
    private enum CodingKeys: String, CodingKey {
        case type
    }
    
    public init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let type = try container.decode(String.self, forKey: .type)
        
        switch type {
        case "user":
            let userMessage = try UserMessage(from: decoder)
            self = .user(userMessage)
        case "assistant":
            let assistantMessage = try AssistantMessage(from: decoder)
            self = .assistant(assistantMessage)
        case "system":
            let systemMessage = try SystemMessage(from: decoder)
            self = .system(systemMessage)
        case "result":
            let resultMessage = try ResultMessage(from: decoder)
            self = .result(resultMessage)
        default:
            throw DecodingError.dataCorrupted(
                DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Unknown message type: \(type)")
            )
        }
    }
    
    public func encode(to encoder: any Encoder) throws {
        switch self {
        case .user(let userMessage):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode("user", forKey: .type)
            try userMessage.encode(to: encoder)
        case .assistant(let assistantMessage):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode("assistant", forKey: .type)
            try assistantMessage.encode(to: encoder)
        case .system(let systemMessage):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode("system", forKey: .type)
            try systemMessage.encode(to: encoder)
        case .result(let resultMessage):
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode("result", forKey: .type)
            try resultMessage.encode(to: encoder)
        }
    }
}

// MARK: - User Message

/// A message from the user
public struct UserMessage: Codable, Sendable {
    public let role: String
    public let content: UserContent
    public let parentToolUseId: String?
    public let sessionId: String
    
    public enum UserContent: Codable, Sendable {
        case text(String)
        case blocks([any ContentBlock])
        
        public init(from decoder: any Decoder) throws {
            let container = try decoder.singleValueContainer()
            
            // Try to decode as string first
            if let string = try? container.decode(String.self) {
                self = .text(string)
                return
            }
            
            // Try to decode as array of content blocks
            if let blocksData = try? container.decode([AnyCodable].self) {
                var blocks: [any ContentBlock] = []
                
                for blockData in blocksData {
                    if let dict = blockData.value as? [String: Any] {
                        let data = try JSONSerialization.data(withJSONObject: dict)
                        
                        // Try to decode each content block type
                        if let textBlock = try? JSONDecoder().decode(TextBlock.self, from: data) {
                            blocks.append(textBlock)
                        } else if let thinkingBlock = try? JSONDecoder().decode(ThinkingBlock.self, from: data) {
                            blocks.append(thinkingBlock)
                        } else if let toolResultBlock = try? JSONDecoder().decode(ToolResultBlock.self, from: data) {
                            blocks.append(toolResultBlock)
                        }
                    }
                }
                
                self = .blocks(blocks)
                return
            }
            
            throw DecodingError.dataCorruptedError(
                in: container,
                debugDescription: "UserMessage content must be either String or [ContentBlock]"
            )
        }
        
        public func encode(to encoder: any Encoder) throws {
            var container = encoder.singleValueContainer()
            
            switch self {
            case .text(let string):
                try container.encode(string)
            case .blocks(let blocks):
                // Encode as array of dictionaries with type information
                var blockDicts: [[String: Any]] = []
                
                for block in blocks {
                    if let textBlock = block as? TextBlock {
                        blockDicts.append([
                            "type": "text",
                            "text": textBlock.text
                        ])
                    } else if let thinkingBlock = block as? ThinkingBlock {
                        blockDicts.append([
                            "type": "thinking",
                            "thinking": thinkingBlock.thinking,
                            "signature": thinkingBlock.signature
                        ])
                    } else if let toolResultBlock = block as? ToolResultBlock {
                        var dict: [String: Any] = [
                            "type": "tool_result",
                            "tool_use_id": toolResultBlock.toolUseId
                        ]
                        if let content = toolResultBlock.content {
                            switch content {
                            case .text(let text):
                                dict["content"] = text
                            case .structured(let structured):
                                dict["content"] = structured
                            }
                        }
                        if let isError = toolResultBlock.isError {
                            dict["is_error"] = isError
                        }
                        blockDicts.append(dict)
                    }
                }
                
                try container.encode(blockDicts.map { AnyCodable($0) })
            }
        }
    }
    
    public init(content: String, parentToolUseId: String? = nil, sessionId: String, role: String = "user") {
        self.role = role
        self.content = .text(content)
        self.parentToolUseId = parentToolUseId
        self.sessionId = sessionId
    }
    
    public init(content: [any ContentBlock], parentToolUseId: String? = nil, sessionId: String, role: String = "user") {
        self.role = role
        self.content = .blocks(content)
        self.parentToolUseId = parentToolUseId
        self.sessionId = sessionId
    }
    
    public init(content: UserContent, parentToolUseId: String? = nil, sessionId: String, role: String = "user") {
        self.role = role
        self.content = content
        self.parentToolUseId = parentToolUseId
        self.sessionId = sessionId
    }
    
    // Custom Codable implementation for UserMessage
    private enum CodingKeys: String, CodingKey {
        case role
        case content
        case parentToolUseId = "parent_tool_use_id"
        case sessionId = "session_id"
    }
    
    public init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.role = try container.decode(String.self, forKey: .role)
        self.content = try container.decode(UserContent.self, forKey: .content)
        self.parentToolUseId = try container.decodeIfPresent(String.self, forKey: .parentToolUseId)
        self.sessionId = try container.decode(String.self, forKey: .sessionId)
    }
    
    public func encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(role, forKey: .role)
        try container.encode(content, forKey: .content)
        try container.encodeIfPresent(parentToolUseId, forKey: .parentToolUseId)
        try container.encode(sessionId, forKey: .sessionId)
    }
}

// MARK: - Assistant Message

/// A message from the assistant containing various content blocks
public struct AssistantMessage: Codable, Sendable {
    public let id: String
    public let role: String
    public let content: [any ContentBlock]
    public let model: String
    public let stopReason: String?
    public let stopSequence: String?
    public let usage: UsageInfo?
    public let parentToolUseId: String?
    public let sessionId: String
    
    public init(
        id: String,
        role: String = "assistant",
        content: [any ContentBlock],
        model: String,
        stopReason: String? = nil,
        stopSequence: String? = nil,
        usage: UsageInfo? = nil,
        parentToolUseId: String? = nil,
        sessionId: String
    ) {
        self.id = id
        self.role = role
        self.content = content
        self.model = model
        self.stopReason = stopReason
        self.stopSequence = stopSequence
        self.usage = usage
        self.parentToolUseId = parentToolUseId
        self.sessionId = sessionId
    }
    
    // Custom Codable implementation for heterogeneous array
    private enum CodingKeys: String, CodingKey {
        case id
        case role
        case content
        case model
        case stopReason = "stop_reason"
        case stopSequence = "stop_sequence"
        case usage
        case parentToolUseId = "parent_tool_use_id"
        case sessionId = "session_id"
    }
    
    private enum ContentBlockType: String, Codable {
        case text
        case thinking
        case toolUse = "tool_use"
    }
    
    private struct TypedContentBlock: Codable {
        let type: ContentBlockType
        let block: AnyCodable
    }
    
    public init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let typedBlocks = try container.decode([TypedContentBlock].self, forKey: .content)
        
        self.id = try container.decode(String.self, forKey: .id)
        self.role = try container.decode(String.self, forKey: .role)
        self.model = try container.decode(String.self, forKey: .model)
        self.stopReason = try container.decodeIfPresent(String.self, forKey: .stopReason)
        self.stopSequence = try container.decodeIfPresent(String.self, forKey: .stopSequence)
        self.usage = try container.decodeIfPresent(UsageInfo.self, forKey: .usage)
        self.parentToolUseId = try container.decodeIfPresent(String.self, forKey: .parentToolUseId)
        self.sessionId = try container.decode(String.self, forKey: .sessionId)
        
        var blocks: [any ContentBlock] = []
        
        for typedBlock in typedBlocks {
            switch typedBlock.type {
            case .text:
                if let dict = typedBlock.block.value as? [String: Any],
                   let text = dict["text"] as? String {
                    blocks.append(TextBlock(text: text))
                }
            case .thinking:
                if let dict = typedBlock.block.value as? [String: Any],
                   let thinking = dict["thinking"] as? String,
                   let signature = dict["signature"] as? String {
                    blocks.append(ThinkingBlock(thinking: thinking, signature: signature))
                }
            case .toolUse:
                if let dict = typedBlock.block.value as? [String: Any],
                   let id = dict["id"] as? String,
                   let name = dict["name"] as? String,
                   let input = dict["input"] as? [String: Any] {
                    let anyCodableInput = input.mapValues { AnyCodable($0) }
                    blocks.append(ToolUseBlock(id: id, name: name, input: anyCodableInput))
                }
            }
        }
        
        self.content = blocks
    }
    
    public func encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(id, forKey: .id)
        try container.encode(role, forKey: .role)
        try container.encode(model, forKey: .model)
        try container.encodeIfPresent(stopReason, forKey: .stopReason)
        try container.encodeIfPresent(stopSequence, forKey: .stopSequence)
        try container.encodeIfPresent(usage, forKey: .usage)
        try container.encodeIfPresent(parentToolUseId, forKey: .parentToolUseId)
        try container.encode(sessionId, forKey: .sessionId)
        
        var typedBlocks: [TypedContentBlock] = []
        
        for block in content {
            if let textBlock = block as? TextBlock {
                typedBlocks.append(TypedContentBlock(
                    type: .text,
                    block: AnyCodable(["text": textBlock.text])
                ))
            } else if let thinkingBlock = block as? ThinkingBlock {
                typedBlocks.append(TypedContentBlock(
                    type: .thinking,
                    block: AnyCodable([
                        "thinking": thinkingBlock.thinking,
                        "signature": thinkingBlock.signature
                    ])
                ))
            } else if let toolUseBlock = block as? ToolUseBlock {
                typedBlocks.append(TypedContentBlock(
                    type: .toolUse,
                    block: AnyCodable([
                        "id": toolUseBlock.id,
                        "name": toolUseBlock.name,
                        "input": toolUseBlock.input
                    ])
                ))
            }
        }
        
        try container.encode(typedBlocks, forKey: .content)
    }
}

// MARK: - System Message

/// A system message containing metadata or control information
/// All fields are optional to handle different system message types efficiently
public struct SystemMessage: Codable, Sendable {
    public let subtype: String
    
    // Init-specific fields (populated for init subtype)
    public let cwd: String?
    public let sessionId: String?
    public let tools: [String]?
    public let mcpServers: [MCPServerInfo]?
    public let model: String?
    public let permissionMode: String?
    public let slashCommands: [String]?
    public let apiKeySource: String?
    
    // Generic data field for other system message types
    public let genericData: [String: AnyCodable]?
    
    public init(
        subtype: String,
        cwd: String? = nil,
        sessionId: String? = nil,
        tools: [String]? = nil,
        mcpServers: [MCPServerInfo]? = nil,
        model: String? = nil,
        permissionMode: String? = nil,
        slashCommands: [String]? = nil,
        apiKeySource: String? = nil,
        genericData: [String: AnyCodable]? = nil
    ) {
        self.subtype = subtype
        self.cwd = cwd
        self.sessionId = sessionId
        self.tools = tools
        self.mcpServers = mcpServers
        self.model = model
        self.permissionMode = permissionMode
        self.slashCommands = slashCommands
        self.apiKeySource = apiKeySource
        self.genericData = genericData
    }
    
    private enum CodingKeys: String, CodingKey {
        case subtype
        case cwd
        case sessionId = "session_id"
        case tools
        case mcpServers = "mcp_servers"
        case model
        case permissionMode
        case slashCommands = "slash_commands"
        case apiKeySource
    }
    
    public init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        self.subtype = try container.decode(String.self, forKey: .subtype)
        
        // Decode all optional fields directly - much faster than enum switching
        self.cwd = try container.decodeIfPresent(String.self, forKey: .cwd)
        self.sessionId = try container.decodeIfPresent(String.self, forKey: .sessionId)
        self.tools = try container.decodeIfPresent([String].self, forKey: .tools)
        self.mcpServers = try container.decodeIfPresent([MCPServerInfo].self, forKey: .mcpServers)
        self.model = try container.decodeIfPresent(String.self, forKey: .model)
        self.permissionMode = try container.decodeIfPresent(String.self, forKey: .permissionMode)
        self.slashCommands = try container.decodeIfPresent([String].self, forKey: .slashCommands)
        self.apiKeySource = try container.decodeIfPresent(String.self, forKey: .apiKeySource)
        
        // For non-init messages, capture any remaining data as generic data
        if subtype != "init" {
            // Decode the entire object and remove known keys
            let allData = try [String: AnyCodable](from: decoder)
            var filtered = allData
            filtered.removeValue(forKey: "subtype")
            self.genericData = filtered.isEmpty ? nil : filtered
        } else {
            self.genericData = nil
        }
    }
    
    public func encode(to encoder: any Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(subtype, forKey: .subtype)
        try container.encodeIfPresent(cwd, forKey: .cwd)
        try container.encodeIfPresent(sessionId, forKey: .sessionId)
        try container.encodeIfPresent(tools, forKey: .tools)
        try container.encodeIfPresent(mcpServers, forKey: .mcpServers)
        try container.encodeIfPresent(model, forKey: .model)
        try container.encodeIfPresent(permissionMode, forKey: .permissionMode)
        try container.encodeIfPresent(slashCommands, forKey: .slashCommands)
        try container.encodeIfPresent(apiKeySource, forKey: .apiKeySource)
        
        // For generic data, encode it as a separate object at the root level
        if let genericData = genericData {
            try genericData.encode(to: encoder)
        }
    }
}

// MARK: - MCP Server Info

/// MCP server information
public struct MCPServerInfo: Codable, Sendable {
    public let name: String
    public let status: String
    
    public init(name: String, status: String) {
        self.name = name
        self.status = status
    }
}

// MARK: - Usage Info

/// Token usage information from Claude API
public struct UsageInfo: Codable, Sendable {
    public let inputTokens: Int
    public let cacheCreationInputTokens: Int?
    public let cacheReadInputTokens: Int?
    public let outputTokens: Int
    public let serviceTier: String?
    public let serverToolUse: [String: AnyCodable]?
    
    public init(
        inputTokens: Int,
        cacheCreationInputTokens: Int? = nil,
        cacheReadInputTokens: Int? = nil,
        outputTokens: Int,
        serviceTier: String? = nil,
        serverToolUse: [String: AnyCodable]? = nil
    ) {
        self.inputTokens = inputTokens
        self.cacheCreationInputTokens = cacheCreationInputTokens
        self.cacheReadInputTokens = cacheReadInputTokens
        self.outputTokens = outputTokens
        self.serviceTier = serviceTier
        self.serverToolUse = serverToolUse
    }
    
    private enum CodingKeys: String, CodingKey {
        case inputTokens = "input_tokens"
        case cacheCreationInputTokens = "cache_creation_input_tokens"
        case cacheReadInputTokens = "cache_read_input_tokens"
        case outputTokens = "output_tokens"
        case serviceTier = "service_tier"
        case serverToolUse = "server_tool_use"
    }
}

// MARK: - Result Message

/// A result message containing session summary and usage information
public struct ResultMessage: Codable, Sendable {
    public let subtype: String
    public let durationMs: Int
    public let durationApiMs: Int
    public let isError: Bool
    public let numTurns: Int
    public let sessionId: String
    public let totalCostUsd: Double?
    public let usage: UsageInfo?
    public let result: String?
    
    public init(
        subtype: String,
        durationMs: Int,
        durationApiMs: Int,
        isError: Bool,
        numTurns: Int,
        sessionId: String,
        totalCostUsd: Double? = nil,
        usage: UsageInfo? = nil,
        result: String? = nil
    ) {
        self.subtype = subtype
        self.durationMs = durationMs
        self.durationApiMs = durationApiMs
        self.isError = isError
        self.numTurns = numTurns
        self.sessionId = sessionId
        self.totalCostUsd = totalCostUsd
        self.usage = usage
        self.result = result
    }
    
    private enum CodingKeys: String, CodingKey {
        case subtype
        case durationMs = "duration_ms"
        case durationApiMs = "duration_api_ms"
        case isError = "is_error"
        case numTurns = "num_turns"
        case sessionId = "session_id"
        case totalCostUsd = "total_cost_usd"
        case usage
        case result
    }
}