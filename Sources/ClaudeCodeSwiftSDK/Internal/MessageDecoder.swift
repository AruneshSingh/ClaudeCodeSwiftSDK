// This file was generated by Claude

import Foundation

/// Decoder for messages from the Claude Code CLI
enum MessageDecoder {
    
    /// Decode a message from a JSON line
    /// - Parameter line: The JSON line from CLI output
    /// - Returns: The decoded message
    /// - Throws: ClaudeSDKError if decoding fails
    static func decode(from line: String) async throws -> Message {
        guard let data = line.data(using: .utf8) else {
            throw ClaudeSDKError.jsonDecodeError(
                line: line,
                error: DecodingError.dataCorrupted(
                    DecodingError.Context(codingPath: [], debugDescription: "Invalid UTF-8 string")
                )
            )
        }
        
        return try await decodeFromData(data, originalLine: line)
    }
    
    /// Decode a message from JSON data
    /// - Parameters:
    ///   - data: The JSON data to decode
    ///   - originalLine: Optional original line for error reporting
    /// - Returns: The decoded message
    /// - Throws: ClaudeSDKError if decoding fails
    static func decodeFromData(_ data: Data, originalLine: String? = nil) async throws -> Message {
        
        // First, decode to determine message type
        let decoder = JSONDecoder()
        
        do {
            // Try to decode a generic structure to determine type
            let genericMessage = try decoder.decode(GenericMessage.self, from: data)
            
            switch genericMessage.type {
            case .user:
                // User messages have content in message.content + optional parent_tool_use_id + session_id
                let parentToolUseId = genericMessage.parent_tool_use_id
                let sessionId = genericMessage.session_id ?? "unknown"
                let role = genericMessage.message?.role ?? "user"
                
                if let messageContent = genericMessage.message?.content?.value {
                    if let content = messageContent as? String {
                        return .user(UserMessage(content: content, parentToolUseId: parentToolUseId, sessionId: sessionId, role: role))
                    } else if let contentArray = messageContent as? [[String: Any]] {
                        // Handle array of content blocks
                        var blocks: [any ContentBlock] = []
                        
                        for blockData in contentArray {
                            // Use direct property access instead of re-encoding/decoding
                            if let type = blockData["type"] as? String {
                                let block: (any ContentBlock)? = {
                                    switch type {
                                    case "text":
                                        guard let text = blockData["text"] as? String else { return nil }
                                        return TextBlock(text: text)
                                        
                                    case "tool_result":
                                        guard let toolUseId = blockData["tool_use_id"] as? String else { return nil }
                                        let isError = blockData["is_error"] as? Bool
                                        
                                        var contentResult: ToolResultBlock.ContentResult?
                                        if let content = blockData["content"] {
                                            if let text = content as? String {
                                                contentResult = .text(text)
                                            } else if let structured = content as? [String: Any] {
                                                contentResult = .structured(structured.mapValues { AnyCodable($0) })
                                            }
                                        }
                                        
                                        return ToolResultBlock(
                                            toolUseId: toolUseId,
                                            content: contentResult,
                                            isError: isError
                                        )
                                        
                                    default:
                                        return nil
                                    }
                                }()
                                
                                if let block = block {
                                    blocks.append(block)
                                }
                            }
                        }
                        
                        return .user(UserMessage(content: blocks, parentToolUseId: parentToolUseId, sessionId: sessionId, role: role))
                    }
                }
                throw ClaudeSDKError.jsonDecodeError(
                    line: originalLine ?? "unknown",
                    error: DecodingError.dataCorrupted(
                        DecodingError.Context(codingPath: [], debugDescription: "Invalid user message content")
                    )
                )
                
            case .assistant:
                return .assistant(try decodeAssistantMessage(from: data))
                
            case .system:
                return .system(try decoder.decode(SystemMessage.self, from: data))
                
            case .result:
                return .result(try decoder.decode(ResultMessage.self, from: data))
            }
        } catch {
            throw ClaudeSDKError.jsonDecodeError(line: originalLine ?? "unknown", error: error)
        }
    }
    
    /// Decode an assistant message with heterogeneous content blocks
    private static func decodeAssistantMessage(from data: Data) throws -> AssistantMessage {
        let decoder = JSONDecoder()
        
        // First decode to a raw structure
        let raw = try decoder.decode(RawAssistantMessage.self, from: data)
        
        var contentBlocks: [any ContentBlock] = []
        
        for rawBlock in raw.message.content {
            switch rawBlock.type {
            case "text":
                if let text = rawBlock.text {
                    contentBlocks.append(TextBlock(text: text))
                }
                
            case "thinking":
                if let thinking = rawBlock.thinking,
                   let signature = rawBlock.signature {
                    contentBlocks.append(ThinkingBlock(thinking: thinking, signature: signature))
                }
                
            case "tool_use":
                if let id = rawBlock.id,
                   let name = rawBlock.name,
                   let input = rawBlock.input {
                    contentBlocks.append(ToolUseBlock(
                        id: id,
                        name: name,
                        input: input.mapValues { AnyCodable($0) }
                    ))
                }
                
            case "tool_result":
                if let toolUseId = rawBlock.tool_use_id {
                    var contentResult: ToolResultBlock.ContentResult?
                    
                    if let content = rawBlock.content {
                        if let text = content as? String {
                            contentResult = .text(text)
                        } else if let structured = content as? [String: Any] {
                            contentResult = .structured(structured.mapValues { AnyCodable($0) })
                        }
                    }
                    
                    contentBlocks.append(ToolResultBlock(
                        toolUseId: toolUseId,
                        content: contentResult,
                        isError: rawBlock.is_error
                    ))
                }
                
            default:
                // Unknown block type, skip
                continue
            }
        }
        
        return AssistantMessage(
            id: raw.message.id,
            role: raw.message.role,
            content: contentBlocks, 
            model: raw.message.model,
            stopReason: raw.message.stop_reason,
            stopSequence: raw.message.stop_sequence,
            usage: raw.message.usage,
            parentToolUseId: raw.parent_tool_use_id,
            sessionId: raw.session_id
        )
    }
    
    // MARK: - Helper Types
    
    /// Generic message structure for type detection
    private struct GenericMessage: Decodable {
        let type: MessageType
        let message: MessageContent?
        let subtype: String?
        let parent_tool_use_id: String?
        let session_id: String?
        
        enum MessageType: String, Decodable {
            case user
            case assistant
            case system
            case result
        }
        
        struct MessageContent: Decodable {
            let id: String?
            let role: String?
            let content: AnyCodable?
            let model: String?
            let stop_reason: String?
            let stop_sequence: String?
            let usage: [String: AnyCodable]?
        }
    }
    
    /// Raw assistant message structure for parsing
    private struct RawAssistantMessage: Decodable {
        let type: String
        let message: MessageData
        let parent_tool_use_id: String?
        let session_id: String
        
        struct MessageData: Decodable {
            let id: String
            let role: String
            let content: [RawContentBlock]
            let model: String
            let stop_reason: String?
            let stop_sequence: String?
            let usage: UsageInfo?
        }
    }
    
    /// Raw content block for parsing
    private struct RawContentBlock: Decodable {
        let type: String
        
        // Text block fields
        let text: String?
        
        // Thinking block fields
        let thinking: String?
        let signature: String?
        
        // Tool use block fields
        let id: String?
        let name: String?
        let input: [String: Any]?
        
        // Tool result block fields
        let tool_use_id: String?
        let content: Any?
        let is_error: Bool?
        
        private enum CodingKeys: String, CodingKey {
            case type
            case text
            case thinking
            case signature
            case id
            case name
            case input
            case tool_use_id
            case content
            case is_error
        }
        
        init(from decoder: any Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            self.type = try container.decode(String.self, forKey: .type)
            self.text = try container.decodeIfPresent(String.self, forKey: .text)
            self.thinking = try container.decodeIfPresent(String.self, forKey: .thinking)
            self.signature = try container.decodeIfPresent(String.self, forKey: .signature)
            self.id = try container.decodeIfPresent(String.self, forKey: .id)
            self.name = try container.decodeIfPresent(String.self, forKey: .name)
            self.tool_use_id = try container.decodeIfPresent(String.self, forKey: .tool_use_id)
            self.is_error = try container.decodeIfPresent(Bool.self, forKey: .is_error)
            
            // Decode dynamic fields
            if let inputData = try? container.decode(AnyCodable.self, forKey: .input) {
                self.input = inputData.value as? [String: Any]
            } else {
                self.input = nil
            }
            
            if let contentData = try? container.decode(AnyCodable.self, forKey: .content) {
                self.content = contentData.value
            } else {
                self.content = nil
            }
        }
    }
}